// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allMatchIds = `-- name: AllMatchIds :many
SELECT matches.id FROM matches
`

func (q *Queries) AllMatchIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, allMatchIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const anyMatches = `-- name: AnyMatches :one
SELECT EXISTS(SELECT 1 FROM matches)
`

func (q *Queries) AnyMatches(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, anyMatches)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createMatch = `-- name: CreateMatch :exec
INSERT INTO matches (match_id, game_start, game_version, winning_team, blue_1_champion_id, blue_2_champion_id, blue_3_champion_id, blue_4_champion_id, blue_5_champion_id, red_1_champion_id, red_2_champion_id, red_3_champion_id, red_4_champion_id, red_5_champion_id) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) RETURNING id
`

type CreateMatchParams struct {
	MatchID         string
	GameStart       pgtype.Timestamp
	GameVersion     string
	WinningTeam     string
	Blue1ChampionID int32
	Blue2ChampionID int32
	Blue3ChampionID int32
	Blue4ChampionID int32
	Blue5ChampionID int32
	Red1ChampionID  int32
	Red2ChampionID  int32
	Red3ChampionID  int32
	Red4ChampionID  int32
	Red5ChampionID  int32
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) error {
	_, err := q.db.Exec(ctx, createMatch,
		arg.MatchID,
		arg.GameStart,
		arg.GameVersion,
		arg.WinningTeam,
		arg.Blue1ChampionID,
		arg.Blue2ChampionID,
		arg.Blue3ChampionID,
		arg.Blue4ChampionID,
		arg.Blue5ChampionID,
		arg.Red1ChampionID,
		arg.Red2ChampionID,
		arg.Red3ChampionID,
		arg.Red4ChampionID,
		arg.Red5ChampionID,
	)
	return err
}

const getMatch = `-- name: GetMatch :one
SELECT id, match_id, game_start, game_version, winning_team, red_1_champion_id, red_2_champion_id, red_3_champion_id, red_4_champion_id, red_5_champion_id, blue_1_champion_id, blue_2_champion_id, blue_3_champion_id, blue_4_champion_id, blue_5_champion_id, created_at FROM matches WHERE id = $1
`

func (q *Queries) GetMatch(ctx context.Context, id int32) (Match, error) {
	row := q.db.QueryRow(ctx, getMatch, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.GameStart,
		&i.GameVersion,
		&i.WinningTeam,
		&i.Red1ChampionID,
		&i.Red2ChampionID,
		&i.Red3ChampionID,
		&i.Red4ChampionID,
		&i.Red5ChampionID,
		&i.Blue1ChampionID,
		&i.Blue2ChampionID,
		&i.Blue3ChampionID,
		&i.Blue4ChampionID,
		&i.Blue5ChampionID,
		&i.CreatedAt,
	)
	return i, err
}

const lastMatches = `-- name: LastMatches :many
SELECT matches.match_id FROM matches ORDER BY created_at DESC LIMIT 10
`

func (q *Queries) LastMatches(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, lastMatches)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var match_id string
		if err := rows.Scan(&match_id); err != nil {
			return nil, err
		}
		items = append(items, match_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchExists = `-- name: MatchExists :one
SELECT EXISTS(SELECT 1 FROM matches WHERE match_id = $1)
`

func (q *Queries) MatchExists(ctx context.Context, matchID string) (bool, error) {
	row := q.db.QueryRow(ctx, matchExists, matchID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
