// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: matches.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const allMatchIds = `-- name: AllMatchIds :many
SELECT matches.id FROM matches
`

func (q *Queries) AllMatchIds(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, allMatchIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const anyMatchesFromServer = `-- name: AnyMatchesFromServer :one
SELECT EXISTS(SELECT 1 FROM matches WHERE server_id = $1)
`

func (q *Queries) AnyMatchesFromServer(ctx context.Context, serverID string) (bool, error) {
	row := q.db.QueryRow(ctx, anyMatchesFromServer, serverID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createMatch = `-- name: CreateMatch :exec
INSERT INTO matches (
    match_id, 
    game_start, 
    game_version, 
    winning_team, 
    queue_id,
    server_id,
    blue_1_champion_id, 
    blue_2_champion_id, 
    blue_3_champion_id, 
    blue_4_champion_id, 
    blue_5_champion_id, 
    red_1_champion_id, 
    red_2_champion_id, 
    red_3_champion_id, 
    red_4_champion_id, 
    red_5_champion_id
  ) 
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16) RETURNING id
`

type CreateMatchParams struct {
	MatchID         string
	GameStart       pgtype.Timestamp
	GameVersion     string
	WinningTeam     string
	QueueID         int32
	ServerID        string
	Blue1ChampionID int32
	Blue2ChampionID int32
	Blue3ChampionID int32
	Blue4ChampionID int32
	Blue5ChampionID int32
	Red1ChampionID  int32
	Red2ChampionID  int32
	Red3ChampionID  int32
	Red4ChampionID  int32
	Red5ChampionID  int32
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) error {
	_, err := q.db.Exec(ctx, createMatch,
		arg.MatchID,
		arg.GameStart,
		arg.GameVersion,
		arg.WinningTeam,
		arg.QueueID,
		arg.ServerID,
		arg.Blue1ChampionID,
		arg.Blue2ChampionID,
		arg.Blue3ChampionID,
		arg.Blue4ChampionID,
		arg.Blue5ChampionID,
		arg.Red1ChampionID,
		arg.Red2ChampionID,
		arg.Red3ChampionID,
		arg.Red4ChampionID,
		arg.Red5ChampionID,
	)
	return err
}

const getMatch = `-- name: GetMatch :one
SELECT id, match_id, game_start, game_version, winning_team, queue_id, server_id, red_1_champion_id, red_2_champion_id, red_3_champion_id, red_4_champion_id, red_5_champion_id, blue_1_champion_id, blue_2_champion_id, blue_3_champion_id, blue_4_champion_id, blue_5_champion_id, created_at FROM matches WHERE id = $1
`

func (q *Queries) GetMatch(ctx context.Context, id int32) (Match, error) {
	row := q.db.QueryRow(ctx, getMatch, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.GameStart,
		&i.GameVersion,
		&i.WinningTeam,
		&i.QueueID,
		&i.ServerID,
		&i.Red1ChampionID,
		&i.Red2ChampionID,
		&i.Red3ChampionID,
		&i.Red4ChampionID,
		&i.Red5ChampionID,
		&i.Blue1ChampionID,
		&i.Blue2ChampionID,
		&i.Blue3ChampionID,
		&i.Blue4ChampionID,
		&i.Blue5ChampionID,
		&i.CreatedAt,
	)
	return i, err
}

const lastMatch = `-- name: LastMatch :one
SELECT id, match_id, game_start, game_version, winning_team, queue_id, server_id, red_1_champion_id, red_2_champion_id, red_3_champion_id, red_4_champion_id, red_5_champion_id, blue_1_champion_id, blue_2_champion_id, blue_3_champion_id, blue_4_champion_id, blue_5_champion_id, created_at FROM matches ORDER BY created_at DESC LIMIT 1
`

func (q *Queries) LastMatch(ctx context.Context) (Match, error) {
	row := q.db.QueryRow(ctx, lastMatch)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.MatchID,
		&i.GameStart,
		&i.GameVersion,
		&i.WinningTeam,
		&i.QueueID,
		&i.ServerID,
		&i.Red1ChampionID,
		&i.Red2ChampionID,
		&i.Red3ChampionID,
		&i.Red4ChampionID,
		&i.Red5ChampionID,
		&i.Blue1ChampionID,
		&i.Blue2ChampionID,
		&i.Blue3ChampionID,
		&i.Blue4ChampionID,
		&i.Blue5ChampionID,
		&i.CreatedAt,
	)
	return i, err
}

const lastMatchesFromServer = `-- name: LastMatchesFromServer :many
SELECT matches.match_id FROM matches WHERE server_id = $1 ORDER BY created_at DESC LIMIT 10
`

func (q *Queries) LastMatchesFromServer(ctx context.Context, serverID string) ([]string, error) {
	rows, err := q.db.Query(ctx, lastMatchesFromServer, serverID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var match_id string
		if err := rows.Scan(&match_id); err != nil {
			return nil, err
		}
		items = append(items, match_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const matchExists = `-- name: MatchExists :one
SELECT EXISTS(SELECT 1 FROM matches WHERE match_id = $1)
`

func (q *Queries) MatchExists(ctx context.Context, matchID string) (bool, error) {
	row := q.db.QueryRow(ctx, matchExists, matchID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
